#include <stdio.h>

int main(void)
{
	int a[3] = {1, 2, 3};
	printf("0번가 %d\n", a[0]);
	printf("1번가 %d\n", a[1]);
	printf("2번가 %d\n", a[2]);
	printf("3번가 %d\n", a[3]);
	
	if(a[3] == '\0')
	{
		printf("3번가 NULL\n");
	}
	//NULL은 아님...
	//다른 값이 들어갈 뿐...
	
	//이렇게도 활용이 됨...
	//배열이 상수인 이유는 여기에..
	printf("0번가 : %d\n", *a);
	printf("1번가 : %d\n", *(a+1));
	printf("2번가 : %d\n", *(a+2));
	//이렇게 한번의 공정을 더 거친 것이 배열의 형태입니다.
	//그래서 배열은 '상수'입니다.
	//만약 햇갈리시면 포인터에서 void pointer를 떠올려서 임시적으로 그때그때 변수로써 활용이 가능한 걸 기억하시면
	//배열이 상수라는 개념은 절대 까먹지 않을 것 입니다.
	
	//포인터는 변수입니다....
	//int *Ptr;
	//가져올 주소 값을 먼저 지정해줘야함. 따라서 이곳에 선언을 하면 error!
	
	//어....그러면 각각 지정은 어떻게?
	int Num1=10;

	//Num1의 주소값을 포인터로 가져온다는 개념으로.
	int *Ptr = &Num1;

	//그...있잖아. scanf때..
	//scanf("%d", &Num1);

	printf("Pointer Ptr : %d\n", *Ptr);


	//1차원에 대한 학습은 여기서 끝..
	
	//여기서는 참고로 알아두면 좋은 다차원 포인터 기초인데..그냥 그렇구나 하고 넘어가는 느낌으로
	//넘어가시고 나중에 필요할때가 되면 나중에 따로 개인적으로 학습을 하는 것으로!!
	//2차원 포인터는...?
	
	int arr[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

	//책에서는 이렇게 안나오고 도형으로 쉽게 나와있을뿐, 원래 배열은 이렇게 일자 형식임.
	//내가 만든 테트레스는 2차원배열이라서 엄청나게 가독성이 구림...
	//이런 특성때문에 3차원과 4차원 배열이 훨씬 가독성도 좋고 만들기도 2차원 배열 테트리스보다  100배는 쉬움..
	
	//위의 배열을 포인터로 나타내면 아래와 같이 선언이 가능함.
	//바로 이렇게....
	
	int *P = (int*)arr;
	//(int*)이렇게  casting을 해주지 않으면....에러가 남.
	//컴파일러는 아주 엄격하기 때문에 서로의 자료형을 잘 맞춰줘야 에러가 나지 않습니다.
	//그러니까...무슨 소리냐면
	//*P로 선언한 포인터는 arr의 첫 번째 주소(숫자 1)를 가져온다는 것이죠..
	
	//한번 봐볼까
	printf("arr 0번가 : %d\n", *P);
	printf("arr 1번가 : %d\n", *(P+1));
	printf("arr 12번가 : %d\n", *(P+11)); //배열의 주소는 0번가부터 시작한다는 것을 잊지마세요!...

	/* compile result
	 	 arr 0번가 : 1
		 arr 1번가 : 2
		 arr 12번가 : 12
	*/

	//원형은 int (*arr_name)[0] = _____;
	//int* 			1차원 포인터
	//int(*)[3] 	2차원 포인터
	//int(*)[2][3]	3차원 포인터
	
	//(*Ptr1)의 값은 {1,2,3,4};와 같다!
	int (*Ptr1)[4] = arr;
	
	//이제 이차원 포인터를 선언.
	//그러나....이렇게 대입을 할 수는 있지만
	//int **Ptr2 = (int**)arr; 
	//선언은 가능. 사용은 불가능.
	//이런 형식은 실제로는 이 2차원 배열이 가리키는 대상이 1차원 포인터의 역할을 해야 하기 때문에
	//항목을 '값'이 아닌 '주소'로 사용하게 되어 구조가 엉망이 되어버리기때문에.
	//주소 값에 서로 혼동을 줄 수 있기 때문에 별로 사용하지 않는 방법.......
	
	//1차원 포인터로도 충분히 2차원배열을 사용이 가능하기 때문에 굳이 안해도 무방.

	printf("0번가 %d\n", (*Ptr1)[0]);
	printf("1번가 %d\n", (*Ptr1)[1]);
	//이렇게도 표현이 가능...!
	printf("1번가 %d\n", *(*Ptr1)+1);

	printf("\n");

	int p = 10;
	int* pt = &p;
	
	int** ppt = &pt;

	printf("p의 값  : %d\n",p);
	printf("&p의 값 : %d\n", &p);
	printf("&p의 값 : %p\n\n", pt);

	printf("*pt의 값 : %d\n", *pt);
	printf("&pt의 값 : %d\n", &pt);
	printf("&pt의 값 : %p\n\n", pt);

	printf("ppt의 값 : %d\n", **ppt);
	printf("&ppt의 값 : %d\n", &ppt);

	//주소를 한 칸 다음에 저장을 시켰으므로....
	//int의 byte크기는 4...
	//4만큼 커진 것을 확인 할 수 있다.
	printf("&ppt의 값 : %p\n\n", ppt);

	
	return (0);
}
